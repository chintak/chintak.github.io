<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>NumPy: The tricks of the trade (Part II) | Notable ML Blog</title><meta name=keywords content="numpy"><meta name=description content="This post will describe about the more advanced and fun stuff about NumPy. For basics, refer to Part I.
Vectorization First let&rsquo;s revisit how we would do any arithmetic operation on all the elements of list (Python in-built container). Looping through all the elements is probably the only way to go about it. The neatest syntax is using list comprehensions.
# List Comprehension >>> L = [1,2,3,4] >>> [i * 2 for i in L] # list comprehension [2, 4, 6, 8] Now imagine doing this for a multi-dimensional list of data and think about the readability."><meta name=author content="Chintak Sheth"><link rel=canonical href=https://chintak.github.io/posts/2013-07-31-numpy-the-tricks-of-the-trade-part-ii/><link crossorigin=anonymous href=/assets/css/stylesheet.0c4fd3725171366f335155acde6fb3c7b7042cd2fd075bebf5023d9b28a701b2.css integrity="sha256-DE/TclFxNm8zUVWs3m+zx7cELNL9B1vr9QI9myinAbI=" rel="preload stylesheet" as=style><link rel=icon href=https://chintak.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://chintak.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://chintak.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://chintak.github.io/apple-touch-icon.png><link rel=mask-icon href=https://chintak.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=text/javascript>MathJax={tex:{displayMath:[["$$","$$"],["\\[","\\]"]],inlineMath:[["$","$"],["\\(","\\)"]]}}</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js integrity=sha384-+BSz3oj3ILMYvOBr16U9i0H4RZRmGyQQ+1q9eqr8T3skmAFrJk8GmgwgqlCZdNSo crossorigin=anonymous referrerpolicy=no-referrer type=text/javascript></script><meta property="og:title" content="NumPy: The tricks of the trade (Part II)"><meta property="og:description" content="This post will describe about the more advanced and fun stuff about NumPy. For basics, refer to Part I.
Vectorization First let&rsquo;s revisit how we would do any arithmetic operation on all the elements of list (Python in-built container). Looping through all the elements is probably the only way to go about it. The neatest syntax is using list comprehensions.
# List Comprehension >>> L = [1,2,3,4] >>> [i * 2 for i in L] # list comprehension [2, 4, 6, 8] Now imagine doing this for a multi-dimensional list of data and think about the readability."><meta property="og:type" content="article"><meta property="og:url" content="https://chintak.github.io/posts/2013-07-31-numpy-the-tricks-of-the-trade-part-ii/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2013-07-31T00:00:00+00:00"><meta property="article:modified_time" content="2013-07-31T00:00:00+00:00"><meta property="og:see_also" content="https://chintak.github.io/posts/2013-07-15-numpy-the-tricks-of-trade-part-i/"><meta name=twitter:card content="summary"><meta name=twitter:title content="NumPy: The tricks of the trade (Part II)"><meta name=twitter:description content="This post will describe about the more advanced and fun stuff about NumPy. For basics, refer to Part I.
Vectorization First let&rsquo;s revisit how we would do any arithmetic operation on all the elements of list (Python in-built container). Looping through all the elements is probably the only way to go about it. The neatest syntax is using list comprehensions.
# List Comprehension >>> L = [1,2,3,4] >>> [i * 2 for i in L] # list comprehension [2, 4, 6, 8] Now imagine doing this for a multi-dimensional list of data and think about the readability."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://chintak.github.io/posts/"},{"@type":"ListItem","position":2,"name":"NumPy: The tricks of the trade (Part II)","item":"https://chintak.github.io/posts/2013-07-31-numpy-the-tricks-of-the-trade-part-ii/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"NumPy: The tricks of the trade (Part II)","name":"NumPy: The tricks of the trade (Part II)","description":"This post will describe about the more advanced and fun stuff about NumPy. For basics, refer to Part I.\nVectorization First let\u0026rsquo;s revisit how we would do any arithmetic operation on all the elements of list (Python in-built container). Looping through all the elements is probably the only way to go about it. The neatest syntax is using list comprehensions.\n# List Comprehension \u0026gt;\u0026gt;\u0026gt; L = [1,2,3,4] \u0026gt;\u0026gt;\u0026gt; [i * 2 for i in L] # list comprehension [2, 4, 6, 8] Now imagine doing this for a multi-dimensional list of data and think about the readability.","keywords":["numpy"],"articleBody":" This post will describe about the more advanced and fun stuff about NumPy. For basics, refer to Part I.\nVectorization First let’s revisit how we would do any arithmetic operation on all the elements of list (Python in-built container). Looping through all the elements is probably the only way to go about it. The neatest syntax is using list comprehensions.\n# List Comprehension \u003e\u003e\u003e L = [1,2,3,4] \u003e\u003e\u003e [i * 2 for i in L] # list comprehension [2, 4, 6, 8] Now imagine doing this for a multi-dimensional list of data and think about the readability. Not so cool, right? This is what vectorization takes care of for NumPy arrays.\n# Example of Vectorized operation \u003e\u003e\u003e a = np.array([1,2,3,4]) \u003e\u003e\u003e a * 2 array([2, 4, 6, 8]) Simply put, vectorization takes one elemental operation and applies to all the elements in that array for you. Underneath, the implementatiosn are in C, hence providing substantial speed gains. NumPy already has a large number of operations vectorized, for eg: all arithmetic operators, logical operators, etc. Numpy also provides a way for you to vectorize your function. All you need to do is:\nWrite a function to do the operation you want to do, taking the elements of the array as arguments.\nVectorize the function.\nProvide the arrays as inputs to this vectorized function.\nDone\n# Creating your own Vectorized function # Note that the following function would already be vectorized since `+` and `**` operations are vectorized \u003e\u003e\u003e def add_square(a, b): ... return (a + b)**2 ... \u003e\u003e\u003e a_array = np.array([1,2,3]) \u003e\u003e\u003e b_array = np.array([4,5,6]) \u003e\u003e\u003e vadd_square = np.vectorize(add_square) \u003e\u003e\u003e vadd_square(a_array, b_array) array([25, 49, 81]) This would help skip a lot of loops in your implementation. Towards the end of this post I’ll provide an example which would help connect all the ideas listed here and enable you to perform really powerful operations rather trivially using NumPy. I’ve completely become a fan of NumPy!\nBroadcasting If I ask you the answer to “banana * orange = ?”, you’ll most certainly look at me as if I’m crazy. But as it turns out, NumPy is also capable of handling operations between arrays of different sizes. The only criteria being that, NumPy should be able to extend all the arrays involved in an operation to a common shape. This is what we call Broadcasting. Let me give couple of examples to further elaborate on this idea.\n# Broadcasting - Basic example \u003e\u003e\u003e a = np.array([0,1,2,3]) \u003e\u003e\u003e b = np.array([0,1,2,3]) \u003e\u003e\u003e a[:, np.newaxis] - b[np.newaxis, :] array([[ 0, -1, -2, -3], [ 1, 0, -1, -2], [ 2, 1, 0, -1], [ 3, 2, 1, 0]]) Understanding np.newaxis would really be very helpful here. It basically just adds another dimension (axis). (duh!) But you can choose where you want to place the new axis as in x, y or z direction.\n# Broadcasting using `np.newaxis` # For illustration purpose, lets suppose that we want to compute the product of all the indices in a 3D grid \u003e\u003e\u003e a = np.array([0,1,2,3]) \u003e\u003e\u003e b = np.array([0,1,2]) \u003e\u003e\u003e c = np.array([0,1]) \u003e\u003e\u003e a[:, np.newaxis, np.newaxis] * b[np.newaxis, :, np.newaxis] * c[np.newaxis, np.newaxis, :] array([[[0, 0], [0, 0], [0, 0]], [[0, 0], [0, 1], [0, 2]], [[0, 0], [0, 2], [0, 4]], [[0, 0], [0, 3], [0, 6]]]) \u003e\u003e\u003e a.strides (8,) \u003e\u003e\u003e a[:, np.newaxis, np.newaxis].strides (8, 0, 0) Comments\nHere, we are extending a and making it a 3D array using np.newaxis however, as you can see the strides, no additional memory is allocated. This makes things a lot easier, instead of creating 3, 3D arrays and then multiplying. Practically, you can use this for indexing purposes.\n# Using Broadcasting for indexing purpose \u003e\u003e\u003e m = np.arange(24).reshape(4,3,2) \u003e\u003e\u003e m array([[[ 0, 1], [ 2, 3], [ 4, 5]], [[ 6, 7], [ 8, 9], [10, 11]], [[12, 13], [14, 15], [16, 17]], [[18, 19], [20, 21], [22, 23]]]) \u003e\u003e\u003e m[a[:, np.newaxis, np.newaxis], b[np.newaxis, :, np.newaxis], c[np.newaxis, np.newaxis, 0]] array([[[ 0], [ 2], [ 4]], [[ 6], [ 8], [10]], [[12], [14], [16]], [[18], [20], [22]]]) np.ogrid You can also this function to create a row array and a column array, and use broadcasting to generate a complete array as follows:\n# Using `np.ogrid` - Basics \u003e\u003e\u003e row, col = np.ogrid[0:3, 0:3] # note it's not a function \u003e\u003e\u003e row, col array([[0], [1], [2]]), array([[0, 1, 2]]) \u003e\u003e\u003e a = np.arange(16).reshape(4,4) \u003e\u003e\u003e a array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11], [12, 13, 14, 15]]) \u003e\u003e\u003e a[0+row, 0+col] array([[ 0, 1, 2], [ 4, 5, 6], [ 8, 9, 10]]) \u003e\u003e\u003e a[1+row, 1+col] array([[ 5, 6, 7], [ 9, 10, 11], [13, 14, 15]]) # OR \u003e\u003e\u003e a[1:4, 1:4] Comments\nHere, we generate a row and column array using np.ogrid (note that its not a function). The option with slicing does look like a neater and cleaner approach, however if you want to do this in a loop with a lot of variables flying around, it may not be the best approach.\nnumpy.lib.stride_tricks.as_strided This is one of the wonders of NumPy which has the power to make loops outdated. Strides, is a method in which NumPy can keep a track or this is how it knows how to get to the nest element in the row or column. How many leaps in the memory to the next element ? This of course also depends on the data type you are using. For example:\n# Concept of strides with data types \u003e\u003e\u003e a = np.array([[1,2,3], [4,5,6]], dtype=np.uint8) \u003e\u003e\u003e a.strides (3, 1) \u003e\u003e\u003e a = np.array([[1,2,3], [4,5,6]], dtype=np.uint16) \u003e\u003e\u003e a.strides (6, 2) Comments\nSo, in the first case, take move 1 byte to get to the next column element and 3 bytes to get to the next row element. Similarly for the second case.\nNow, let’s see how as_strided works and how can we use this to perform many operations efficiently. Crudely, this function provides a way to access the same underlying array in different shapes. That being said there is also an option to define different strides for this particular view on the array. As we all know that by default, we access the elements in a row: C contiguous (or column: fortran contiguous), one after the other. But using this function it is possible to skip elements in the middle and point to say, all the diagonal elements only, hence enabling you to extract the diagonal entries of even a multi-dimensional tensor using just this function and not allocating any additional memory for the same. Some examples:\n# Understanding `as_strided` \u003e\u003e\u003e a = np.arange(9, dtype=np.uint8).reshape(3,3) \u003e\u003e\u003e a array([[0, 1, 2], [3, 4, 5], [6, 7, 8]], dtype=uint8) \u003e\u003e\u003e a.itemsize # Number of bytes taken by each element 1 \u003e\u003e\u003e a.strides (3, 1) \u003e\u003e\u003e from numpy.lib.stride_tricks import as_strided \u003e\u003e\u003e a_view = as_strided(a, shape=(3, ), strides=((3+1)*a.itemsize, )) \u003e\u003e\u003e a_view array([0, 4, 8], dtype=uint8) \u003e\u003e\u003e a_view.strides (4,) Comments\nAny changes in this strided view will also get reflected in the original array.\n# `as_strided` provides a view; not a copy of the array \u003e\u003e\u003e a_view[1] = 10 \u003e\u003e\u003e a array([[ 0, 1, 2], [ 3, 10, 5], [ 6, 7, 8]], dtype=uint8) Caution: This function does not check whether you stay inside the memory block bounds. This could lead to some garbage values popping up.\n# as_strided does not check for memory bounds - you have to! \u003e\u003e\u003e a_view = as_strided(a, shape=(4, ), strides=((3+1)*a.itemsize, )) \u003e\u003e\u003e a_view array([ 0, 10, 8, 0], dtype=uint8) In fact, it is this command over memory layout which helps NumPy perform wonders like Broadcasting. This is how broadcasting is really implemented underneath, using 0 strides.\n# Broadcasting and as_strided - Same underneath \u003e\u003e\u003e a = np.arange(4, dtype=np.uint8) \u003e\u003e\u003e a array([0, 1, 2, 3], dtype=uint8) \u003e\u003e\u003e a.strides (1,) \u003e\u003e\u003e a_view = as_strided(a, shape=(4,4), strides=(0, 1)) \u003e\u003e\u003e a_view array([[0, 1, 2, 3], [0, 1, 2, 3], [0, 1, 2, 3], [0, 1, 2, 3]], dtype=uint8) \u003e\u003e\u003e b_view = as_strided(a, shape=(4,4), strides=(1, 0)) \u003e\u003e\u003e b_view array([[0, 0, 0, 0], [1, 1, 1, 1], [2, 2, 2, 2], [3, 3, 3, 3]], dtype=uint8) \u003e\u003e\u003e b_view[1,1] = 4 \u003e\u003e\u003e b_view array([[0, 0, 0, 0], [4, 4, 4, 4], [2, 2, 2, 2], [3, 3, 3, 3]], dtype=uint8) Comments\nAs you can see, all the “1” were really just a single “1”. Hence, when you change any of the element, the change is reflected everywhere since in reality they are all the same.\nnp.einsum This stands for Einstein’s summation. Using this function you can implement a lot of in-built functions involving summation. The syntax is as follows:\n# Basics of `np.einsum` \u003e\u003e\u003e a = np.arange(16).reshape(4,4) \u003e\u003e\u003e a array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11], [12, 13, 14, 15]]) \u003e\u003e\u003e np.einsum('ii', a) 30 \u003e\u003e\u003e np.einsum('ij', a) array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11], [12, 13, 14, 15]]) \u003e\u003e\u003e np.einsum('ji', a) array([[ 0, 4, 8, 12], [ 1, 5, 9, 13], [ 2, 6, 10, 14], [ 3, 7, 11, 15]]) The idea is to represent each dimension (axis) by a label, ‘i’ or ‘j’ here. It is similar to iterating over a loop. In the first case, it picks up all the elements where the indices in both the dimensions are equal and sums it over, summation of the diagonal elements, trace of the array. The order in which the label is alphabetical and important. In the second example, since ‘j’ appears after ‘i’, it first loops through elements along the column. The third example, hence produces the transpose. Now, let’s see an example involving some what more complex applications of np.einsum.\n# Advanced examples - check below for explanation \u003e\u003e\u003e a = np.arange(24).reshape(6,4) \u003e\u003e\u003e a array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11], [12, 13, 14, 15], [16, 17, 18, 19], [20, 21, 22, 23]]) \u003e\u003e\u003e b = np.arange(6) \u003e\u003e\u003e b array([0, 1, 2, 3, 4, 5]) \u003e\u003e\u003e np.einsum('ij, i-\u003ej', a,b) # Column sum array([220, 235, 250, 265]) \u003e\u003e\u003e np.einsum('ij, i-\u003ei', a,b) # Row sum array([ 0, 22, 76, 162, 280, 430]) Comments\nWe use -\u003e to indicate the order of the output array. So think of 'ij, i-\u003ej' as having left hand side (LHS) and right hand side (RHS). Any repetition of labels on the LHS computes the product element wise and then sums over. By changing the label on the RHS (output) side, we can define the axis in which we want to proceed with respect to the input array, i.e. summation along axis 0, 1 and so on. The above two examples can also be computed rather trivially, as follows:\n# Alternate to `np.einsum`: Product and reduce \u003e\u003e\u003e a*b[:,np.newaxis] array([[ 0, 0, 0, 0], [ 4, 5, 6, 7], [ 16, 18, 20, 22], [ 36, 39, 42, 45], [ 64, 68, 72, 76], [100, 105, 110, 115]]) \u003e\u003e\u003e (a*b[:,np.newaxis]).sum(1) array([ 0, 22, 76, 162, 280, 430]) \u003e\u003e\u003e (a*b[:,np.newaxis]).sum(0) array([220, 235, 250, 265]) Complete Example Finally, before concluding this post, I would like to give an example, real code which I am using in my project, to help connect all these ideas and put them in perspective.\nHere is the task: Template Matching\nExtract a small windowXwindow template/patch about a pixel, i.e. this pixel should also be the centre of patch. (call it template patch)\nLoop: Compute a patch about all pixels in the image (call it, sample patch)\nFind the Sum of Squared Differences (SSD) of the template and the sample patch Find the patch with the minimum SSD\nThe most obvious way to go about this would be using a nested loop. The code for the same is as follows:\n# Template Matching using loops total_weight = valid_mask.sum() for i in xrange(h): for j in xrange(w): sample = image[i - (window / 2): i + (window / 2) + 1, j - (window / 2): j + (window / 2) + 1] dist = (template - sample) ** 2 ssd[i, j] = dist.sum() / total_weight # `total_weight` is just for normalization Now this piece of code, doesn’t seem all that scary and probably you’d do this every now and then in C/C++. However, Python loops are pretty darn slow. My complete code with this ran in about 19.37 seconds. The majority of the time being spent here.\nHowever, there is a better way to write this. For starters, lets get rid of the huge slicing syntax with… np.ogrid, of course.\n# np.ogrid for better indexing t_row, t_col = np.ogrid[-(window / 2):(window / 2) + 1, -(window / 2):(window / 2) + 1] You would argue about how would using this be any different, well it’s not! It’s just cleaner and more convenient to write this once and henceforth simply use the following to extract a template of size window X window about a pixel.\ninput_image[i + t_row, j + t_col] Much like shifting of origin in Geometry! Let’s rethink, why are we really using the nested loops here? To extract template of the given size pixel by pixel and perform the operations. Is it possible to create such templates beforehand and perform the arithmetic operations directly on all the templates, leveraging the vector property of operators? However, creating separate templates for every pixel would most certainly be expensive on the memory. How can we do this without any additional memory overhead? as_strided!\n# as_strided to provide a `window` sized window to the `input_image` y = as_strided(input_image, shape=(input_image.shape[0] - window_size[0] + 1, input_image.shape[1] - window_size[1] + 1,) + window_size, strides=input_image.strides * 2) Suppose here, that input_image has the dimensions (M, N), the resulting strided view, y would be a 4D array with (M, N, window, window) dimensions, as specified by the shape key argument. Note that input_image.strides * 2 represents a multiplication on a tuple which replicates and concatenates the tuple.\n# as_strided work here \u003e\u003e\u003e input_image = np.arange(16).reshape(4,4) \u003e\u003e\u003e input_image array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11], [12, 13, 14, 15]]) \u003e\u003e\u003e y = as_strided(input_image, ... shape=(input_image.shape[0] - window_size[0] + 1, ... input_image.shape[1] - window_size[1] + 1,) + ... window_size, ... strides=input_image.strides * 2) \u003e\u003e\u003e y array([[[[ 0, 1, 2], [ 4, 5, 6], [ 8, 9, 10]], [[ 1, 2, 3], [ 5, 6, 7], [ 9, 10, 11]]], [[[ 4, 5, 6], [ 8, 9, 10], [12, 13, 14]], [[ 5, 6, 7], [ 9, 10, 11], [13, 14, 15]]]]) \u003e\u003e\u003e y[0,0] array([[ 0, 1, 2], [ 4, 5, 6], [ 8, 9, 10]]) \u003e\u003e\u003e y[1,1] array([[ 5, 6, 7], [ 9, 10, 11], [13, 14, 15]]) \u003e\u003e\u003e y.shape (2, 2, 3, 3) \u003e\u003e\u003e y.strides (32, 8, 32, 8) # 8 is the min step since this data type is 'int64' which occupies 8 bytes \u003e\u003e\u003e y.itemsize 8 \u003e\u003e\u003e y.dtype dtype('int64') So, as we can see here, if we iterate through the 1st 2 dimensions of y we will have a 3X3 array with elements surrounding the inner elements of input_image. I find this to be extremely fascinating and really just brilliant!\nRemember: as_strided is just a view, so Without adding any additional memory overhead we are able to accomplish this.\nWarning: In spite of being just a view, directly performing arithmetic operations on this would allocate additional memory, a 4D that too! This would neutralise the unique advantage this stands to offer. Here, is where things get even more exciting: np.einsum.\n# Using `np.einsum` to calculate the SSD without additional mem allocation ssd = np.einsum('ijkl, kl, kl-\u003eij', y, template, valid_mask, dtype=np.float) ssd *= - 2 ssd += np.einsum('ijkl, ijkl, kl-\u003eij', y, y, valid_mask) ssd += np.einsum('ij, ij, ij', template, template, valid_mask) Instead of directly computing the square of the difference (proving to be rather costly), use the basic algebraic expansion: (a - b)**2 = a**2 - 2*a*b + b**2. Here, observe that, in the first computation, which calculates sample * template the output is being stored in a 2D array. Following which, the subsequent results are simply accumulated in this very array. So in the end, still the overall memory load is just of allocating this 2D array for storing the output, which is what we sought for.\nThe complete function which serves as a replacement for the nested loop is as follows:\n# Complete Template Matching function - no loops def _sum_sq_diff(input_image, template, valid_mask): \"\"\"This function performs template matching. The metric used is Sum of Squared Difference (SSD). The input taken is the template who's match is to be found in image. Parameters --------- input_image : array, np.float Input image of shape (M, N) template : array, np.float (window, window) Template who's match is to be found in input_image. valid_mask : array, np.float (window, window), governs differences which are to be considered for SSD computation. Masks out the unknown or unfilled pixels and gives a higher weightage to the center pixel, decreasing as the distance from center pixel increases. Returns ------ ssd : array, np.float (M - window +1, N - window + 1) The desired SSD values for all positions in the input_image \"\"\" total_weight = valid_mask.sum() window_size = template.shape y = as_strided(input_image, shape=(input_image.shape[0] - window_size[0] + 1, input_image.shape[1] - window_size[1] + 1,) + window_size, strides=input_image.strides * 2) ssd = np.einsum('ijkl, kl, kl-\u003eij', y, template, valid_mask, dtype=np.float) # Refer to the comment below for the explanation ssd *= - 2 ssd += np.einsum('ijkl, ijkl, kl-\u003eij', y, y, valid_mask) ssd += np.einsum('ij, ij, ij', template, template, valid_mask) return ssd / total_weight Comments\nAbove, since ‘kl’ are repeated on LHS, we first compute the product of elements in the 3rd and 4th dim of y with corresponding elements of template and valid_mask and sum. Since, the output labels are ‘ij’, we want the summation along the other axes. Hence, each element of ssd corresponds to element wise product of template and valid_mask with the (3, 3) “sample patch” stored in the 3rd and 4th dimensions of y.\nResults\nThe fascinating part is that testing this implementation for the same test case as the one used for nested loops completes the computation in about 0.342 seconds! So that’s 19.37 -\u003e 0.34 seconds!\nI am absolutely blown away by NumPy, and if not for anything else, I am definitely thankful to GSoC and scikit-image for introducing me to NumPy!\nNext post will be on my second module for GSoC: Texture Synthesis, whose initial implementation is complete and now in the review phase.\nCheers!\nReferences Much of the content of this post is inspired from the StackOverflow answer to my question by Jaime, of scikit-image community. Thanks a lot! Answer\nhttp://scipy-lectures.github.io/\nVan Der Walt, Stefan, S. Chris Colbert, and Gael Varoquaux. “The NumPy array: a structure for efficient numerical computation.” Computing in Science \u0026 Engineering 13.2 (2011): 22-30.\nRelated articles NumPy: The tricks of the trade (Part I)\nDiving into NumPy Code, SciPy 2013 Tutorial\nUsing NumPy to Perform Mathematical Operations in Python\nUpdates [Feb 2, 2013] Added another example to the section on np.einsum and comment explaining the role of np.einsum in the _sum_sq_diff function. Thanks for pointing out, Juan! ","wordCount":"3181","inLanguage":"en","datePublished":"2013-07-31T00:00:00Z","dateModified":"2013-07-31T00:00:00Z","author":{"@type":"Person","name":"Chintak Sheth"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://chintak.github.io/posts/2013-07-31-numpy-the-tricks-of-the-trade-part-ii/"},"publisher":{"@type":"Organization","name":"Notable ML Blog","logo":{"@type":"ImageObject","url":"https://chintak.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://chintak.github.io/ accesskey=h title="Notable ML Blog (Alt + H)">Notable ML Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://chintak.github.io/ title=Posts><span>Posts</span></a></li><li><a href=https://chintak.github.io/archives title=Archives><span>Archives</span></a></li><li><a href=https://chintak.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://chintak.github.io/tags title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>NumPy: The tricks of the trade (Part II)</h1><div class=post-meta><span title='2013-07-31 00:00:00 +0000 UTC'>July 31, 2013</span>&nbsp;·&nbsp;15 min&nbsp;·&nbsp;3181 words&nbsp;·&nbsp;Chintak Sheth</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#vectorization aria-label=Vectorization>Vectorization</a></li><li><a href=#broadcasting aria-label=Broadcasting>Broadcasting</a><ul><li><a href=#npogrid aria-label=np.ogrid><code>np.ogrid</code></a></li></ul></li><li><a href=#numpylibstride_tricksas_strided aria-label=numpy.lib.stride_tricks.as_strided><code>numpy.lib.stride_tricks.as_strided</code></a></li><li><a href=#npeinsum aria-label=np.einsum><code>np.einsum</code></a></li><li><a href=#complete-example aria-label="Complete Example">Complete Example</a></li><li><a href=#references aria-label=References>References</a></li><li><a href=#related-articles aria-label="Related articles">Related articles</a></li><li><a href=#updates aria-label=Updates>Updates</a></li></ul></div></details></div><div class=post-content><hr><p>This post will describe about the more advanced and fun stuff about <a href=http://www.numpy.org/>NumPy</a>. For basics, refer to <a href=notion://www.notion.so/posts/2013-07-30-numpy-the-tricks-of-trade-part-i/>Part I</a>.</p><h2 id=vectorization>Vectorization<a hidden class=anchor aria-hidden=true href=#vectorization>#</a></h2><p>First let&rsquo;s revisit how we would do any arithmetic operation on all the elements of list (<a href=http://www.python.org/>Python</a> in-built container). Looping through all the elements is probably the only way to go about it. The neatest syntax is using <a href=http://en.wikipedia.org/wiki/List_comprehension>list comprehensions</a>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#6272a4># List Comprehension</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>&gt;&gt;&gt;</span> L <span style=color:#ff79c6>=</span> [<span style=color:#bd93f9>1</span>,<span style=color:#bd93f9>2</span>,<span style=color:#bd93f9>3</span>,<span style=color:#bd93f9>4</span>]
</span></span><span style=display:flex><span><span style=color:#ff79c6>&gt;&gt;&gt;</span> [i <span style=color:#ff79c6>*</span> <span style=color:#bd93f9>2</span> <span style=color:#ff79c6>for</span> i <span style=color:#ff79c6>in</span> L]  <span style=color:#6272a4># list comprehension</span>
</span></span><span style=display:flex><span>[<span style=color:#bd93f9>2</span>, <span style=color:#bd93f9>4</span>, <span style=color:#bd93f9>6</span>, <span style=color:#bd93f9>8</span>]
</span></span></code></pre></div><p>Now imagine doing this for a multi-dimensional list of data and think about the readability. Not so cool, right? This is what vectorization takes care of for NumPy arrays.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#6272a4># Example of Vectorized operation</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>&gt;&gt;&gt;</span> a <span style=color:#ff79c6>=</span> np<span style=color:#ff79c6>.</span>array([<span style=color:#bd93f9>1</span>,<span style=color:#bd93f9>2</span>,<span style=color:#bd93f9>3</span>,<span style=color:#bd93f9>4</span>])
</span></span><span style=display:flex><span><span style=color:#ff79c6>&gt;&gt;&gt;</span> a <span style=color:#ff79c6>*</span> <span style=color:#bd93f9>2</span>
</span></span><span style=display:flex><span>array([<span style=color:#bd93f9>2</span>, <span style=color:#bd93f9>4</span>, <span style=color:#bd93f9>6</span>, <span style=color:#bd93f9>8</span>])
</span></span></code></pre></div><p>Simply put, vectorization takes one elemental operation and applies to all the elements in that array for you. Underneath, the implementatiosn are in C, hence providing substantial speed gains. NumPy already has a large number of operations vectorized, for eg: all arithmetic operators, logical operators, etc.
Numpy also provides a way for you to vectorize your function. All you need to do is:</p><ul><li><p>Write a function to do the operation you want to do, taking the elements of the array as arguments.</p></li><li><p>Vectorize the function.</p></li><li><p>Provide the arrays as inputs to this vectorized function.</p></li><li><p>Done</p></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#6272a4># Creating your own Vectorized function</span>
</span></span><span style=display:flex><span><span style=color:#6272a4># Note that the following function would already be vectorized since `+` and `**` operations are vectorized</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>&gt;&gt;&gt;</span> <span style=color:#ff79c6>def</span> <span style=color:#50fa7b>add_square</span>(a, b):
</span></span><span style=display:flex><span><span style=color:#ff79c6>...</span>     <span style=color:#ff79c6>return</span> (a <span style=color:#ff79c6>+</span> b)<span style=color:#ff79c6>**</span><span style=color:#bd93f9>2</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>...</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>&gt;&gt;&gt;</span> a_array <span style=color:#ff79c6>=</span> np<span style=color:#ff79c6>.</span>array([<span style=color:#bd93f9>1</span>,<span style=color:#bd93f9>2</span>,<span style=color:#bd93f9>3</span>])
</span></span><span style=display:flex><span><span style=color:#ff79c6>&gt;&gt;&gt;</span> b_array <span style=color:#ff79c6>=</span> np<span style=color:#ff79c6>.</span>array([<span style=color:#bd93f9>4</span>,<span style=color:#bd93f9>5</span>,<span style=color:#bd93f9>6</span>])
</span></span><span style=display:flex><span><span style=color:#ff79c6>&gt;&gt;&gt;</span> vadd_square <span style=color:#ff79c6>=</span> np<span style=color:#ff79c6>.</span>vectorize(add_square)
</span></span><span style=display:flex><span><span style=color:#ff79c6>&gt;&gt;&gt;</span> vadd_square(a_array, b_array)
</span></span><span style=display:flex><span>array([<span style=color:#bd93f9>25</span>, <span style=color:#bd93f9>49</span>, <span style=color:#bd93f9>81</span>])
</span></span></code></pre></div><p>This would help skip a lot of loops in your implementation. Towards the end of this post I&rsquo;ll provide an example which would help connect all the ideas listed here and enable you to perform really powerful operations rather trivially using NumPy. I&rsquo;ve completely become a fan of NumPy!</p><h2 id=broadcasting>Broadcasting<a hidden class=anchor aria-hidden=true href=#broadcasting>#</a></h2><p>If I ask you the answer to &ldquo;banana * orange = ?&rdquo;, you&rsquo;ll most certainly look at me as if I&rsquo;m crazy. But as it turns out, NumPy is also capable of handling operations between arrays of different sizes. The only criteria being that, NumPy should be able to extend all the arrays involved in an operation to a common shape. This is what we call Broadcasting. Let me give couple of examples to further elaborate on this idea.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#6272a4># Broadcasting - Basic example</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>&gt;&gt;&gt;</span> a <span style=color:#ff79c6>=</span> np<span style=color:#ff79c6>.</span>array([<span style=color:#bd93f9>0</span>,<span style=color:#bd93f9>1</span>,<span style=color:#bd93f9>2</span>,<span style=color:#bd93f9>3</span>])
</span></span><span style=display:flex><span><span style=color:#ff79c6>&gt;&gt;&gt;</span> b <span style=color:#ff79c6>=</span> np<span style=color:#ff79c6>.</span>array([<span style=color:#bd93f9>0</span>,<span style=color:#bd93f9>1</span>,<span style=color:#bd93f9>2</span>,<span style=color:#bd93f9>3</span>])
</span></span><span style=display:flex><span><span style=color:#ff79c6>&gt;&gt;&gt;</span> a[:, np<span style=color:#ff79c6>.</span>newaxis] <span style=color:#ff79c6>-</span> b[np<span style=color:#ff79c6>.</span>newaxis, :]
</span></span><span style=display:flex><span>array([[ <span style=color:#bd93f9>0</span>, <span style=color:#ff79c6>-</span><span style=color:#bd93f9>1</span>, <span style=color:#ff79c6>-</span><span style=color:#bd93f9>2</span>, <span style=color:#ff79c6>-</span><span style=color:#bd93f9>3</span>],
</span></span><span style=display:flex><span>       [ <span style=color:#bd93f9>1</span>, <span style=color:#bd93f9>0</span>, <span style=color:#ff79c6>-</span><span style=color:#bd93f9>1</span>, <span style=color:#ff79c6>-</span><span style=color:#bd93f9>2</span>],
</span></span><span style=display:flex><span>       [ <span style=color:#bd93f9>2</span>, <span style=color:#bd93f9>1</span>, <span style=color:#bd93f9>0</span>, <span style=color:#ff79c6>-</span><span style=color:#bd93f9>1</span>],
</span></span><span style=display:flex><span>       [ <span style=color:#bd93f9>3</span>, <span style=color:#bd93f9>2</span>, <span style=color:#bd93f9>1</span>, <span style=color:#bd93f9>0</span>]])
</span></span></code></pre></div><p>Understanding <code>np.newaxis</code> would really be very helpful here. It basically just adds another dimension (axis). (duh!) But you can choose where you want to place the new axis as in x, y or z direction.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#6272a4># Broadcasting using `np.newaxis`</span>
</span></span><span style=display:flex><span><span style=color:#6272a4># For illustration purpose, lets suppose that we want to compute the product of all the indices in a 3D grid</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>&gt;&gt;&gt;</span> a <span style=color:#ff79c6>=</span> np<span style=color:#ff79c6>.</span>array([<span style=color:#bd93f9>0</span>,<span style=color:#bd93f9>1</span>,<span style=color:#bd93f9>2</span>,<span style=color:#bd93f9>3</span>])
</span></span><span style=display:flex><span><span style=color:#ff79c6>&gt;&gt;&gt;</span> b <span style=color:#ff79c6>=</span> np<span style=color:#ff79c6>.</span>array([<span style=color:#bd93f9>0</span>,<span style=color:#bd93f9>1</span>,<span style=color:#bd93f9>2</span>])
</span></span><span style=display:flex><span><span style=color:#ff79c6>&gt;&gt;&gt;</span> c <span style=color:#ff79c6>=</span> np<span style=color:#ff79c6>.</span>array([<span style=color:#bd93f9>0</span>,<span style=color:#bd93f9>1</span>])
</span></span><span style=display:flex><span><span style=color:#ff79c6>&gt;&gt;&gt;</span> a[:, np<span style=color:#ff79c6>.</span>newaxis, np<span style=color:#ff79c6>.</span>newaxis] <span style=color:#ff79c6>*</span> b[np<span style=color:#ff79c6>.</span>newaxis, :, np<span style=color:#ff79c6>.</span>newaxis] <span style=color:#ff79c6>*</span> c[np<span style=color:#ff79c6>.</span>newaxis, np<span style=color:#ff79c6>.</span>newaxis, :]
</span></span><span style=display:flex><span>array([[[<span style=color:#bd93f9>0</span>, <span style=color:#bd93f9>0</span>],
</span></span><span style=display:flex><span>        [<span style=color:#bd93f9>0</span>, <span style=color:#bd93f9>0</span>],
</span></span><span style=display:flex><span>        [<span style=color:#bd93f9>0</span>, <span style=color:#bd93f9>0</span>]],
</span></span><span style=display:flex><span>       [[<span style=color:#bd93f9>0</span>, <span style=color:#bd93f9>0</span>],
</span></span><span style=display:flex><span>        [<span style=color:#bd93f9>0</span>, <span style=color:#bd93f9>1</span>],
</span></span><span style=display:flex><span>        [<span style=color:#bd93f9>0</span>, <span style=color:#bd93f9>2</span>]],
</span></span><span style=display:flex><span>       [[<span style=color:#bd93f9>0</span>, <span style=color:#bd93f9>0</span>],
</span></span><span style=display:flex><span>        [<span style=color:#bd93f9>0</span>, <span style=color:#bd93f9>2</span>],
</span></span><span style=display:flex><span>        [<span style=color:#bd93f9>0</span>, <span style=color:#bd93f9>4</span>]],
</span></span><span style=display:flex><span>       [[<span style=color:#bd93f9>0</span>, <span style=color:#bd93f9>0</span>],
</span></span><span style=display:flex><span>        [<span style=color:#bd93f9>0</span>, <span style=color:#bd93f9>3</span>],
</span></span><span style=display:flex><span>        [<span style=color:#bd93f9>0</span>, <span style=color:#bd93f9>6</span>]]])
</span></span><span style=display:flex><span><span style=color:#ff79c6>&gt;&gt;&gt;</span> a<span style=color:#ff79c6>.</span>strides
</span></span><span style=display:flex><span>(<span style=color:#bd93f9>8</span>,)
</span></span><span style=display:flex><span><span style=color:#ff79c6>&gt;&gt;&gt;</span> a[:, np<span style=color:#ff79c6>.</span>newaxis, np<span style=color:#ff79c6>.</span>newaxis]<span style=color:#ff79c6>.</span>strides
</span></span><span style=display:flex><span>(<span style=color:#bd93f9>8</span>, <span style=color:#bd93f9>0</span>, <span style=color:#bd93f9>0</span>)
</span></span></code></pre></div><p><strong>Comments</strong></p><p>Here, we are extending <code>a</code> and making it a 3D array using <code>np.newaxis</code> however, as you can see the strides, no additional memory is allocated. This makes things a lot easier, instead of creating 3, 3D arrays and then multiplying.
Practically, you can use this for indexing purposes.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#6272a4># Using Broadcasting for indexing purpose</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>&gt;&gt;&gt;</span> m <span style=color:#ff79c6>=</span> np<span style=color:#ff79c6>.</span>arange(<span style=color:#bd93f9>24</span>)<span style=color:#ff79c6>.</span>reshape(<span style=color:#bd93f9>4</span>,<span style=color:#bd93f9>3</span>,<span style=color:#bd93f9>2</span>)
</span></span><span style=display:flex><span><span style=color:#ff79c6>&gt;&gt;&gt;</span> m
</span></span><span style=display:flex><span>array([[[ <span style=color:#bd93f9>0</span>,  <span style=color:#bd93f9>1</span>],
</span></span><span style=display:flex><span>        [ <span style=color:#bd93f9>2</span>,  <span style=color:#bd93f9>3</span>],
</span></span><span style=display:flex><span>        [ <span style=color:#bd93f9>4</span>,  <span style=color:#bd93f9>5</span>]],
</span></span><span style=display:flex><span>       [[ <span style=color:#bd93f9>6</span>,  <span style=color:#bd93f9>7</span>],
</span></span><span style=display:flex><span>        [ <span style=color:#bd93f9>8</span>,  <span style=color:#bd93f9>9</span>],
</span></span><span style=display:flex><span>        [<span style=color:#bd93f9>10</span>, <span style=color:#bd93f9>11</span>]],
</span></span><span style=display:flex><span>       [[<span style=color:#bd93f9>12</span>, <span style=color:#bd93f9>13</span>],
</span></span><span style=display:flex><span>        [<span style=color:#bd93f9>14</span>, <span style=color:#bd93f9>15</span>],
</span></span><span style=display:flex><span>        [<span style=color:#bd93f9>16</span>, <span style=color:#bd93f9>17</span>]],
</span></span><span style=display:flex><span>       [[<span style=color:#bd93f9>18</span>, <span style=color:#bd93f9>19</span>],
</span></span><span style=display:flex><span>        [<span style=color:#bd93f9>20</span>, <span style=color:#bd93f9>21</span>],
</span></span><span style=display:flex><span>        [<span style=color:#bd93f9>22</span>, <span style=color:#bd93f9>23</span>]]])
</span></span><span style=display:flex><span><span style=color:#ff79c6>&gt;&gt;&gt;</span> m[a[:, np<span style=color:#ff79c6>.</span>newaxis, np<span style=color:#ff79c6>.</span>newaxis], b[np<span style=color:#ff79c6>.</span>newaxis, :, np<span style=color:#ff79c6>.</span>newaxis], c[np<span style=color:#ff79c6>.</span>newaxis, np<span style=color:#ff79c6>.</span>newaxis, <span style=color:#bd93f9>0</span>]]
</span></span><span style=display:flex><span>array([[[ <span style=color:#bd93f9>0</span>],
</span></span><span style=display:flex><span>        [ <span style=color:#bd93f9>2</span>],
</span></span><span style=display:flex><span>        [ <span style=color:#bd93f9>4</span>]],
</span></span><span style=display:flex><span>       [[ <span style=color:#bd93f9>6</span>],
</span></span><span style=display:flex><span>        [ <span style=color:#bd93f9>8</span>],
</span></span><span style=display:flex><span>        [<span style=color:#bd93f9>10</span>]],
</span></span><span style=display:flex><span>       [[<span style=color:#bd93f9>12</span>],
</span></span><span style=display:flex><span>        [<span style=color:#bd93f9>14</span>],
</span></span><span style=display:flex><span>        [<span style=color:#bd93f9>16</span>]],
</span></span><span style=display:flex><span>       [[<span style=color:#bd93f9>18</span>],
</span></span><span style=display:flex><span>        [<span style=color:#bd93f9>20</span>],
</span></span><span style=display:flex><span>        [<span style=color:#bd93f9>22</span>]]])
</span></span></code></pre></div><h3 id=npogrid><code>np.ogrid</code><a hidden class=anchor aria-hidden=true href=#npogrid>#</a></h3><p>You can also this function to create a row array and a column array, and use broadcasting to generate a complete array as follows:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#6272a4># Using `np.ogrid` - Basics</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>&gt;&gt;&gt;</span> row, col <span style=color:#ff79c6>=</span> np<span style=color:#ff79c6>.</span>ogrid[<span style=color:#bd93f9>0</span>:<span style=color:#bd93f9>3</span>, <span style=color:#bd93f9>0</span>:<span style=color:#bd93f9>3</span>]  <span style=color:#6272a4># note it&#39;s not a function</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>&gt;&gt;&gt;</span> row, col
</span></span><span style=display:flex><span>array([[<span style=color:#bd93f9>0</span>],
</span></span><span style=display:flex><span>       [<span style=color:#bd93f9>1</span>],
</span></span><span style=display:flex><span>       [<span style=color:#bd93f9>2</span>]]), array([[<span style=color:#bd93f9>0</span>, <span style=color:#bd93f9>1</span>, <span style=color:#bd93f9>2</span>]])
</span></span><span style=display:flex><span><span style=color:#ff79c6>&gt;&gt;&gt;</span> a <span style=color:#ff79c6>=</span> np<span style=color:#ff79c6>.</span>arange(<span style=color:#bd93f9>16</span>)<span style=color:#ff79c6>.</span>reshape(<span style=color:#bd93f9>4</span>,<span style=color:#bd93f9>4</span>)
</span></span><span style=display:flex><span><span style=color:#ff79c6>&gt;&gt;&gt;</span> a
</span></span><span style=display:flex><span>array([[ <span style=color:#bd93f9>0</span>,  <span style=color:#bd93f9>1</span>,  <span style=color:#bd93f9>2</span>,  <span style=color:#bd93f9>3</span>],
</span></span><span style=display:flex><span>       [ <span style=color:#bd93f9>4</span>,  <span style=color:#bd93f9>5</span>,  <span style=color:#bd93f9>6</span>,  <span style=color:#bd93f9>7</span>],
</span></span><span style=display:flex><span>       [ <span style=color:#bd93f9>8</span>,  <span style=color:#bd93f9>9</span>, <span style=color:#bd93f9>10</span>, <span style=color:#bd93f9>11</span>],
</span></span><span style=display:flex><span>       [<span style=color:#bd93f9>12</span>, <span style=color:#bd93f9>13</span>, <span style=color:#bd93f9>14</span>, <span style=color:#bd93f9>15</span>]])
</span></span><span style=display:flex><span><span style=color:#ff79c6>&gt;&gt;&gt;</span> a[<span style=color:#bd93f9>0</span><span style=color:#ff79c6>+</span>row, <span style=color:#bd93f9>0</span><span style=color:#ff79c6>+</span>col]
</span></span><span style=display:flex><span>array([[ <span style=color:#bd93f9>0</span>,  <span style=color:#bd93f9>1</span>,  <span style=color:#bd93f9>2</span>],
</span></span><span style=display:flex><span>       [ <span style=color:#bd93f9>4</span>,  <span style=color:#bd93f9>5</span>,  <span style=color:#bd93f9>6</span>],
</span></span><span style=display:flex><span>       [ <span style=color:#bd93f9>8</span>,  <span style=color:#bd93f9>9</span>, <span style=color:#bd93f9>10</span>]])
</span></span><span style=display:flex><span><span style=color:#ff79c6>&gt;&gt;&gt;</span> a[<span style=color:#bd93f9>1</span><span style=color:#ff79c6>+</span>row, <span style=color:#bd93f9>1</span><span style=color:#ff79c6>+</span>col]
</span></span><span style=display:flex><span>array([[ <span style=color:#bd93f9>5</span>,  <span style=color:#bd93f9>6</span>,  <span style=color:#bd93f9>7</span>],
</span></span><span style=display:flex><span>       [ <span style=color:#bd93f9>9</span>, <span style=color:#bd93f9>10</span>, <span style=color:#bd93f9>11</span>],
</span></span><span style=display:flex><span>       [<span style=color:#bd93f9>13</span>, <span style=color:#bd93f9>14</span>, <span style=color:#bd93f9>15</span>]])
</span></span><span style=display:flex><span><span style=color:#6272a4>#  OR</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>&gt;&gt;&gt;</span> a[<span style=color:#bd93f9>1</span>:<span style=color:#bd93f9>4</span>, <span style=color:#bd93f9>1</span>:<span style=color:#bd93f9>4</span>]
</span></span></code></pre></div><p><strong>Comments</strong></p><p>Here, we generate a row and column array using <code>np.ogrid</code> (note that its not a function). The option with slicing does look like a neater and cleaner approach, however if you want to do this in a loop with a lot of variables flying around, it may not be the best approach.</p><h2 id=numpylibstride_tricksas_strided><code>numpy.lib.stride_tricks.as_strided</code><a hidden class=anchor aria-hidden=true href=#numpylibstride_tricksas_strided>#</a></h2><p>This is one of the wonders of NumPy which has the power to make loops outdated. Strides, is a method in which NumPy can keep a track or this is how it knows how to get to the nest element in the row or column. How many leaps in the memory to the next element ? This of course also depends on the data type you are using. For example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#6272a4># Concept of strides with data types</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>&gt;&gt;&gt;</span> a <span style=color:#ff79c6>=</span> np<span style=color:#ff79c6>.</span>array([[<span style=color:#bd93f9>1</span>,<span style=color:#bd93f9>2</span>,<span style=color:#bd93f9>3</span>], [<span style=color:#bd93f9>4</span>,<span style=color:#bd93f9>5</span>,<span style=color:#bd93f9>6</span>]], dtype<span style=color:#ff79c6>=</span>np<span style=color:#ff79c6>.</span>uint8)
</span></span><span style=display:flex><span><span style=color:#ff79c6>&gt;&gt;&gt;</span> a<span style=color:#ff79c6>.</span>strides
</span></span><span style=display:flex><span>(<span style=color:#bd93f9>3</span>, <span style=color:#bd93f9>1</span>)
</span></span><span style=display:flex><span><span style=color:#ff79c6>&gt;&gt;&gt;</span> a <span style=color:#ff79c6>=</span> np<span style=color:#ff79c6>.</span>array([[<span style=color:#bd93f9>1</span>,<span style=color:#bd93f9>2</span>,<span style=color:#bd93f9>3</span>], [<span style=color:#bd93f9>4</span>,<span style=color:#bd93f9>5</span>,<span style=color:#bd93f9>6</span>]], dtype<span style=color:#ff79c6>=</span>np<span style=color:#ff79c6>.</span>uint16)
</span></span><span style=display:flex><span><span style=color:#ff79c6>&gt;&gt;&gt;</span> a<span style=color:#ff79c6>.</span>strides
</span></span><span style=display:flex><span>(<span style=color:#bd93f9>6</span>, <span style=color:#bd93f9>2</span>)
</span></span></code></pre></div><p><strong>Comments</strong></p><p>So, in the first case, take move 1 byte to get to the next column element and 3 bytes to get to the next row element. Similarly for the second case.</p><p>Now, let&rsquo;s see how <code>as_strided</code> works and how can we use this to perform many operations efficiently. Crudely, this function provides a way to access the same underlying array in different shapes. That being said there is also an option to define different strides for this particular view on the array. As we all know that by default, we access the elements in a row: C contiguous (or column: fortran contiguous), one after the other. But using this function it is possible to skip elements in the middle and point to say, all the diagonal elements only, hence enabling you to extract the diagonal entries of even a multi-dimensional tensor using just this function and not allocating any additional memory for the same. Some examples:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#6272a4># Understanding `as_strided`</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>&gt;&gt;&gt;</span> a <span style=color:#ff79c6>=</span> np<span style=color:#ff79c6>.</span>arange(<span style=color:#bd93f9>9</span>, dtype<span style=color:#ff79c6>=</span>np<span style=color:#ff79c6>.</span>uint8)<span style=color:#ff79c6>.</span>reshape(<span style=color:#bd93f9>3</span>,<span style=color:#bd93f9>3</span>)
</span></span><span style=display:flex><span><span style=color:#ff79c6>&gt;&gt;&gt;</span> a
</span></span><span style=display:flex><span>array([[<span style=color:#bd93f9>0</span>, <span style=color:#bd93f9>1</span>, <span style=color:#bd93f9>2</span>],
</span></span><span style=display:flex><span>       [<span style=color:#bd93f9>3</span>, <span style=color:#bd93f9>4</span>, <span style=color:#bd93f9>5</span>],
</span></span><span style=display:flex><span>       [<span style=color:#bd93f9>6</span>, <span style=color:#bd93f9>7</span>, <span style=color:#bd93f9>8</span>]], dtype<span style=color:#ff79c6>=</span>uint8)
</span></span><span style=display:flex><span><span style=color:#ff79c6>&gt;&gt;&gt;</span> a<span style=color:#ff79c6>.</span>itemsize  <span style=color:#6272a4># Number of bytes taken by each element</span>
</span></span><span style=display:flex><span><span style=color:#bd93f9>1</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>&gt;&gt;&gt;</span> a<span style=color:#ff79c6>.</span>strides
</span></span><span style=display:flex><span>(<span style=color:#bd93f9>3</span>, <span style=color:#bd93f9>1</span>)
</span></span><span style=display:flex><span><span style=color:#ff79c6>&gt;&gt;&gt;</span> <span style=color:#ff79c6>from</span> numpy.lib.stride_tricks <span style=color:#ff79c6>import</span> as_strided
</span></span><span style=display:flex><span><span style=color:#ff79c6>&gt;&gt;&gt;</span> a_view <span style=color:#ff79c6>=</span> as_strided(a, shape<span style=color:#ff79c6>=</span>(<span style=color:#bd93f9>3</span>, ), strides<span style=color:#ff79c6>=</span>((<span style=color:#bd93f9>3</span><span style=color:#ff79c6>+</span><span style=color:#bd93f9>1</span>)<span style=color:#ff79c6>*</span>a<span style=color:#ff79c6>.</span>itemsize, ))
</span></span><span style=display:flex><span><span style=color:#ff79c6>&gt;&gt;&gt;</span> a_view
</span></span><span style=display:flex><span>array([<span style=color:#bd93f9>0</span>, <span style=color:#bd93f9>4</span>, <span style=color:#bd93f9>8</span>], dtype<span style=color:#ff79c6>=</span>uint8)
</span></span><span style=display:flex><span><span style=color:#ff79c6>&gt;&gt;&gt;</span> a_view<span style=color:#ff79c6>.</span>strides
</span></span><span style=display:flex><span>(<span style=color:#bd93f9>4</span>,)
</span></span></code></pre></div><p><strong>Comments</strong></p><p>Any changes in this strided view will also get reflected in the original array.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#6272a4># `as_strided` provides a view; not a copy of the array</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>&gt;&gt;&gt;</span> a_view[<span style=color:#bd93f9>1</span>] <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>10</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>&gt;&gt;&gt;</span> a
</span></span><span style=display:flex><span>array([[ <span style=color:#bd93f9>0</span>,  <span style=color:#bd93f9>1</span>,  <span style=color:#bd93f9>2</span>],
</span></span><span style=display:flex><span>       [ <span style=color:#bd93f9>3</span>, <span style=color:#bd93f9>10</span>,  <span style=color:#bd93f9>5</span>],
</span></span><span style=display:flex><span>       [ <span style=color:#bd93f9>6</span>,  <span style=color:#bd93f9>7</span>,  <span style=color:#bd93f9>8</span>]], dtype<span style=color:#ff79c6>=</span>uint8)
</span></span></code></pre></div><blockquote><p>Caution: This function does not check whether you stay inside the memory block bounds. This could lead to some garbage values popping up.</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#6272a4># as_strided does not check for memory bounds - you have to!</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>&gt;&gt;&gt;</span> a_view <span style=color:#ff79c6>=</span> as_strided(a, shape<span style=color:#ff79c6>=</span>(<span style=color:#bd93f9>4</span>, ), strides<span style=color:#ff79c6>=</span>((<span style=color:#bd93f9>3</span><span style=color:#ff79c6>+</span><span style=color:#bd93f9>1</span>)<span style=color:#ff79c6>*</span>a<span style=color:#ff79c6>.</span>itemsize, ))
</span></span><span style=display:flex><span><span style=color:#ff79c6>&gt;&gt;&gt;</span> a_view
</span></span><span style=display:flex><span>array([ <span style=color:#bd93f9>0</span>, <span style=color:#bd93f9>10</span>,  <span style=color:#bd93f9>8</span>,  <span style=color:#bd93f9>0</span>], dtype<span style=color:#ff79c6>=</span>uint8)
</span></span></code></pre></div><p><em>In fact, it is this command over memory layout which helps NumPy perform wonders like Broadcasting. This is how broadcasting is really implemented underneath, using 0 strides.</em></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#6272a4># Broadcasting and as_strided - Same underneath</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>&gt;&gt;&gt;</span> a <span style=color:#ff79c6>=</span> np<span style=color:#ff79c6>.</span>arange(<span style=color:#bd93f9>4</span>, dtype<span style=color:#ff79c6>=</span>np<span style=color:#ff79c6>.</span>uint8)
</span></span><span style=display:flex><span><span style=color:#ff79c6>&gt;&gt;&gt;</span> a
</span></span><span style=display:flex><span>array([<span style=color:#bd93f9>0</span>, <span style=color:#bd93f9>1</span>, <span style=color:#bd93f9>2</span>, <span style=color:#bd93f9>3</span>], dtype<span style=color:#ff79c6>=</span>uint8)
</span></span><span style=display:flex><span><span style=color:#ff79c6>&gt;&gt;&gt;</span> a<span style=color:#ff79c6>.</span>strides
</span></span><span style=display:flex><span>(<span style=color:#bd93f9>1</span>,)
</span></span><span style=display:flex><span><span style=color:#ff79c6>&gt;&gt;&gt;</span> a_view <span style=color:#ff79c6>=</span> as_strided(a, shape<span style=color:#ff79c6>=</span>(<span style=color:#bd93f9>4</span>,<span style=color:#bd93f9>4</span>), strides<span style=color:#ff79c6>=</span>(<span style=color:#bd93f9>0</span>, <span style=color:#bd93f9>1</span>))
</span></span><span style=display:flex><span><span style=color:#ff79c6>&gt;&gt;&gt;</span> a_view
</span></span><span style=display:flex><span>array([[<span style=color:#bd93f9>0</span>, <span style=color:#bd93f9>1</span>, <span style=color:#bd93f9>2</span>, <span style=color:#bd93f9>3</span>],
</span></span><span style=display:flex><span>       [<span style=color:#bd93f9>0</span>, <span style=color:#bd93f9>1</span>, <span style=color:#bd93f9>2</span>, <span style=color:#bd93f9>3</span>],
</span></span><span style=display:flex><span>       [<span style=color:#bd93f9>0</span>, <span style=color:#bd93f9>1</span>, <span style=color:#bd93f9>2</span>, <span style=color:#bd93f9>3</span>],
</span></span><span style=display:flex><span>       [<span style=color:#bd93f9>0</span>, <span style=color:#bd93f9>1</span>, <span style=color:#bd93f9>2</span>, <span style=color:#bd93f9>3</span>]], dtype<span style=color:#ff79c6>=</span>uint8)
</span></span><span style=display:flex><span><span style=color:#ff79c6>&gt;&gt;&gt;</span> b_view <span style=color:#ff79c6>=</span> as_strided(a, shape<span style=color:#ff79c6>=</span>(<span style=color:#bd93f9>4</span>,<span style=color:#bd93f9>4</span>), strides<span style=color:#ff79c6>=</span>(<span style=color:#bd93f9>1</span>, <span style=color:#bd93f9>0</span>))
</span></span><span style=display:flex><span><span style=color:#ff79c6>&gt;&gt;&gt;</span> b_view
</span></span><span style=display:flex><span>array([[<span style=color:#bd93f9>0</span>, <span style=color:#bd93f9>0</span>, <span style=color:#bd93f9>0</span>, <span style=color:#bd93f9>0</span>],
</span></span><span style=display:flex><span>       [<span style=color:#bd93f9>1</span>, <span style=color:#bd93f9>1</span>, <span style=color:#bd93f9>1</span>, <span style=color:#bd93f9>1</span>],
</span></span><span style=display:flex><span>       [<span style=color:#bd93f9>2</span>, <span style=color:#bd93f9>2</span>, <span style=color:#bd93f9>2</span>, <span style=color:#bd93f9>2</span>],
</span></span><span style=display:flex><span>       [<span style=color:#bd93f9>3</span>, <span style=color:#bd93f9>3</span>, <span style=color:#bd93f9>3</span>, <span style=color:#bd93f9>3</span>]], dtype<span style=color:#ff79c6>=</span>uint8)
</span></span><span style=display:flex><span><span style=color:#ff79c6>&gt;&gt;&gt;</span> b_view[<span style=color:#bd93f9>1</span>,<span style=color:#bd93f9>1</span>] <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>4</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>&gt;&gt;&gt;</span> b_view
</span></span><span style=display:flex><span>array([[<span style=color:#bd93f9>0</span>, <span style=color:#bd93f9>0</span>, <span style=color:#bd93f9>0</span>, <span style=color:#bd93f9>0</span>],
</span></span><span style=display:flex><span>       [<span style=color:#bd93f9>4</span>, <span style=color:#bd93f9>4</span>, <span style=color:#bd93f9>4</span>, <span style=color:#bd93f9>4</span>],
</span></span><span style=display:flex><span>       [<span style=color:#bd93f9>2</span>, <span style=color:#bd93f9>2</span>, <span style=color:#bd93f9>2</span>, <span style=color:#bd93f9>2</span>],
</span></span><span style=display:flex><span>       [<span style=color:#bd93f9>3</span>, <span style=color:#bd93f9>3</span>, <span style=color:#bd93f9>3</span>, <span style=color:#bd93f9>3</span>]], dtype<span style=color:#ff79c6>=</span>uint8)
</span></span></code></pre></div><p><strong>Comments</strong></p><p>As you can see, all the &ldquo;1&rdquo; were really just a single &ldquo;1&rdquo;. Hence, when you change any of the element, the change is reflected everywhere since in reality they are all the same.</p><h2 id=npeinsum><code>np.einsum</code><a hidden class=anchor aria-hidden=true href=#npeinsum>#</a></h2><p>This stands for Einstein&rsquo;s summation. Using this function you can implement a lot of in-built functions involving summation. The syntax is as follows:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#6272a4># Basics of `np.einsum`</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>&gt;&gt;&gt;</span> a <span style=color:#ff79c6>=</span> np<span style=color:#ff79c6>.</span>arange(<span style=color:#bd93f9>16</span>)<span style=color:#ff79c6>.</span>reshape(<span style=color:#bd93f9>4</span>,<span style=color:#bd93f9>4</span>)
</span></span><span style=display:flex><span><span style=color:#ff79c6>&gt;&gt;&gt;</span> a
</span></span><span style=display:flex><span>array([[ <span style=color:#bd93f9>0</span>,  <span style=color:#bd93f9>1</span>,  <span style=color:#bd93f9>2</span>,  <span style=color:#bd93f9>3</span>],
</span></span><span style=display:flex><span>       [ <span style=color:#bd93f9>4</span>,  <span style=color:#bd93f9>5</span>,  <span style=color:#bd93f9>6</span>,  <span style=color:#bd93f9>7</span>],
</span></span><span style=display:flex><span>       [ <span style=color:#bd93f9>8</span>,  <span style=color:#bd93f9>9</span>, <span style=color:#bd93f9>10</span>, <span style=color:#bd93f9>11</span>],
</span></span><span style=display:flex><span>       [<span style=color:#bd93f9>12</span>, <span style=color:#bd93f9>13</span>, <span style=color:#bd93f9>14</span>, <span style=color:#bd93f9>15</span>]])
</span></span><span style=display:flex><span><span style=color:#ff79c6>&gt;&gt;&gt;</span> np<span style=color:#ff79c6>.</span>einsum(<span style=color:#f1fa8c>&#39;ii&#39;</span>, a)
</span></span><span style=display:flex><span><span style=color:#bd93f9>30</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>&gt;&gt;&gt;</span> np<span style=color:#ff79c6>.</span>einsum(<span style=color:#f1fa8c>&#39;ij&#39;</span>, a)
</span></span><span style=display:flex><span>array([[ <span style=color:#bd93f9>0</span>,  <span style=color:#bd93f9>1</span>,  <span style=color:#bd93f9>2</span>,  <span style=color:#bd93f9>3</span>],
</span></span><span style=display:flex><span>       [ <span style=color:#bd93f9>4</span>,  <span style=color:#bd93f9>5</span>,  <span style=color:#bd93f9>6</span>,  <span style=color:#bd93f9>7</span>],
</span></span><span style=display:flex><span>       [ <span style=color:#bd93f9>8</span>,  <span style=color:#bd93f9>9</span>, <span style=color:#bd93f9>10</span>, <span style=color:#bd93f9>11</span>],
</span></span><span style=display:flex><span>       [<span style=color:#bd93f9>12</span>, <span style=color:#bd93f9>13</span>, <span style=color:#bd93f9>14</span>, <span style=color:#bd93f9>15</span>]])
</span></span><span style=display:flex><span><span style=color:#ff79c6>&gt;&gt;&gt;</span> np<span style=color:#ff79c6>.</span>einsum(<span style=color:#f1fa8c>&#39;ji&#39;</span>, a)
</span></span><span style=display:flex><span>array([[ <span style=color:#bd93f9>0</span>,  <span style=color:#bd93f9>4</span>,  <span style=color:#bd93f9>8</span>, <span style=color:#bd93f9>12</span>],
</span></span><span style=display:flex><span>       [ <span style=color:#bd93f9>1</span>,  <span style=color:#bd93f9>5</span>,  <span style=color:#bd93f9>9</span>, <span style=color:#bd93f9>13</span>],
</span></span><span style=display:flex><span>       [ <span style=color:#bd93f9>2</span>,  <span style=color:#bd93f9>6</span>, <span style=color:#bd93f9>10</span>, <span style=color:#bd93f9>14</span>],
</span></span><span style=display:flex><span>       [ <span style=color:#bd93f9>3</span>,  <span style=color:#bd93f9>7</span>, <span style=color:#bd93f9>11</span>, <span style=color:#bd93f9>15</span>]])
</span></span></code></pre></div><p>The idea is to represent each dimension (axis) by a label, &lsquo;i&rsquo; or &lsquo;j&rsquo; here. It is similar to iterating over a loop. In the first case, it picks up all the elements where the indices in both the dimensions are equal and sums it over, summation of the diagonal elements, trace of the array. The order in which the label is alphabetical and important. In the second example, since &lsquo;j&rsquo; appears after &lsquo;i&rsquo;, it first loops through elements along the column. The third example, hence produces the transpose. Now, let&rsquo;s see an example involving some what more complex applications of <code>np.einsum</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#6272a4># Advanced examples - check below for explanation</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>&gt;&gt;&gt;</span> a <span style=color:#ff79c6>=</span> np<span style=color:#ff79c6>.</span>arange(<span style=color:#bd93f9>24</span>)<span style=color:#ff79c6>.</span>reshape(<span style=color:#bd93f9>6</span>,<span style=color:#bd93f9>4</span>)
</span></span><span style=display:flex><span><span style=color:#ff79c6>&gt;&gt;&gt;</span> a
</span></span><span style=display:flex><span>array([[ <span style=color:#bd93f9>0</span>,  <span style=color:#bd93f9>1</span>,  <span style=color:#bd93f9>2</span>,  <span style=color:#bd93f9>3</span>],
</span></span><span style=display:flex><span>       [ <span style=color:#bd93f9>4</span>,  <span style=color:#bd93f9>5</span>,  <span style=color:#bd93f9>6</span>,  <span style=color:#bd93f9>7</span>],
</span></span><span style=display:flex><span>       [ <span style=color:#bd93f9>8</span>,  <span style=color:#bd93f9>9</span>, <span style=color:#bd93f9>10</span>, <span style=color:#bd93f9>11</span>],
</span></span><span style=display:flex><span>       [<span style=color:#bd93f9>12</span>, <span style=color:#bd93f9>13</span>, <span style=color:#bd93f9>14</span>, <span style=color:#bd93f9>15</span>],
</span></span><span style=display:flex><span>       [<span style=color:#bd93f9>16</span>, <span style=color:#bd93f9>17</span>, <span style=color:#bd93f9>18</span>, <span style=color:#bd93f9>19</span>],
</span></span><span style=display:flex><span>       [<span style=color:#bd93f9>20</span>, <span style=color:#bd93f9>21</span>, <span style=color:#bd93f9>22</span>, <span style=color:#bd93f9>23</span>]])
</span></span><span style=display:flex><span><span style=color:#ff79c6>&gt;&gt;&gt;</span> b <span style=color:#ff79c6>=</span> np<span style=color:#ff79c6>.</span>arange(<span style=color:#bd93f9>6</span>)
</span></span><span style=display:flex><span><span style=color:#ff79c6>&gt;&gt;&gt;</span> b
</span></span><span style=display:flex><span>array([<span style=color:#bd93f9>0</span>, <span style=color:#bd93f9>1</span>, <span style=color:#bd93f9>2</span>, <span style=color:#bd93f9>3</span>, <span style=color:#bd93f9>4</span>, <span style=color:#bd93f9>5</span>])
</span></span><span style=display:flex><span><span style=color:#ff79c6>&gt;&gt;&gt;</span> np<span style=color:#ff79c6>.</span>einsum(<span style=color:#f1fa8c>&#39;ij, i-&gt;j&#39;</span>, a,b)  <span style=color:#6272a4># Column sum</span>
</span></span><span style=display:flex><span>array([<span style=color:#bd93f9>220</span>, <span style=color:#bd93f9>235</span>, <span style=color:#bd93f9>250</span>, <span style=color:#bd93f9>265</span>])
</span></span><span style=display:flex><span><span style=color:#ff79c6>&gt;&gt;&gt;</span> np<span style=color:#ff79c6>.</span>einsum(<span style=color:#f1fa8c>&#39;ij, i-&gt;i&#39;</span>, a,b)  <span style=color:#6272a4># Row sum</span>
</span></span><span style=display:flex><span>array([  <span style=color:#bd93f9>0</span>,  <span style=color:#bd93f9>22</span>,  <span style=color:#bd93f9>76</span>, <span style=color:#bd93f9>162</span>, <span style=color:#bd93f9>280</span>, <span style=color:#bd93f9>430</span>])
</span></span></code></pre></div><p><strong>Comments</strong></p><p>We use <code>-></code> to indicate the order of the output array. So think of <code>'ij, i->j'</code> as having left hand side (LHS) and right hand side (RHS). Any repetition of labels on the LHS computes the product element wise and then sums over. By changing the label on the RHS (output) side, we can define the axis in which we want to proceed with respect to the input array, i.e. summation along axis 0, 1 and so on. The above two examples can also be computed rather trivially, as follows:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#6272a4># Alternate to `np.einsum`: Product and reduce</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>&gt;&gt;&gt;</span> a<span style=color:#ff79c6>*</span>b[:,np<span style=color:#ff79c6>.</span>newaxis]
</span></span><span style=display:flex><span>array([[  <span style=color:#bd93f9>0</span>,   <span style=color:#bd93f9>0</span>,   <span style=color:#bd93f9>0</span>,   <span style=color:#bd93f9>0</span>],
</span></span><span style=display:flex><span>       [  <span style=color:#bd93f9>4</span>,   <span style=color:#bd93f9>5</span>,   <span style=color:#bd93f9>6</span>,   <span style=color:#bd93f9>7</span>],
</span></span><span style=display:flex><span>       [ <span style=color:#bd93f9>16</span>,  <span style=color:#bd93f9>18</span>,  <span style=color:#bd93f9>20</span>,  <span style=color:#bd93f9>22</span>],
</span></span><span style=display:flex><span>       [ <span style=color:#bd93f9>36</span>,  <span style=color:#bd93f9>39</span>,  <span style=color:#bd93f9>42</span>,  <span style=color:#bd93f9>45</span>],
</span></span><span style=display:flex><span>       [ <span style=color:#bd93f9>64</span>,  <span style=color:#bd93f9>68</span>,  <span style=color:#bd93f9>72</span>,  <span style=color:#bd93f9>76</span>],
</span></span><span style=display:flex><span>       [<span style=color:#bd93f9>100</span>, <span style=color:#bd93f9>105</span>, <span style=color:#bd93f9>110</span>, <span style=color:#bd93f9>115</span>]])
</span></span><span style=display:flex><span><span style=color:#ff79c6>&gt;&gt;&gt;</span> (a<span style=color:#ff79c6>*</span>b[:,np<span style=color:#ff79c6>.</span>newaxis])<span style=color:#ff79c6>.</span>sum(<span style=color:#bd93f9>1</span>)
</span></span><span style=display:flex><span>array([  <span style=color:#bd93f9>0</span>,  <span style=color:#bd93f9>22</span>,  <span style=color:#bd93f9>76</span>, <span style=color:#bd93f9>162</span>, <span style=color:#bd93f9>280</span>, <span style=color:#bd93f9>430</span>])
</span></span><span style=display:flex><span><span style=color:#ff79c6>&gt;&gt;&gt;</span> (a<span style=color:#ff79c6>*</span>b[:,np<span style=color:#ff79c6>.</span>newaxis])<span style=color:#ff79c6>.</span>sum(<span style=color:#bd93f9>0</span>)
</span></span><span style=display:flex><span>array([<span style=color:#bd93f9>220</span>, <span style=color:#bd93f9>235</span>, <span style=color:#bd93f9>250</span>, <span style=color:#bd93f9>265</span>])
</span></span></code></pre></div><h2 id=complete-example>Complete Example<a hidden class=anchor aria-hidden=true href=#complete-example>#</a></h2><p>Finally, before concluding this post, I would like to give an example, real code which I am using in my project, to help connect all these ideas and put them in perspective.</p><p>Here is the task: <strong>Template Matching</strong></p><ul><li><p>Extract a small windowXwindow template/patch about a pixel, i.e. this pixel should also be the centre of patch. (call it template patch)</p></li><li><p>Loop: Compute a patch about all pixels in the image (call it, sample patch)</p><ul><li>Find the Sum of Squared Differences (SSD) of the template and the sample patch</li></ul></li><li><p>Find the patch with the minimum SSD</p></li></ul><p>The most obvious way to go about this would be using a nested loop. The code for the same is as follows:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#6272a4># Template Matching using loops</span>
</span></span><span style=display:flex><span>total_weight <span style=color:#ff79c6>=</span> valid_mask<span style=color:#ff79c6>.</span>sum()
</span></span><span style=display:flex><span><span style=color:#ff79c6>for</span> i <span style=color:#ff79c6>in</span> xrange(h):
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> j <span style=color:#ff79c6>in</span> xrange(w):
</span></span><span style=display:flex><span>        sample <span style=color:#ff79c6>=</span> image[i <span style=color:#ff79c6>-</span> (window <span style=color:#ff79c6>/</span> <span style=color:#bd93f9>2</span>): i <span style=color:#ff79c6>+</span> (window <span style=color:#ff79c6>/</span> <span style=color:#bd93f9>2</span>) <span style=color:#ff79c6>+</span> <span style=color:#bd93f9>1</span>,
</span></span><span style=display:flex><span>j <span style=color:#ff79c6>-</span> (window <span style=color:#ff79c6>/</span> <span style=color:#bd93f9>2</span>): j <span style=color:#ff79c6>+</span> (window <span style=color:#ff79c6>/</span> <span style=color:#bd93f9>2</span>) <span style=color:#ff79c6>+</span> <span style=color:#bd93f9>1</span>]
</span></span><span style=display:flex><span>dist <span style=color:#ff79c6>=</span> (template <span style=color:#ff79c6>-</span> sample) <span style=color:#ff79c6>**</span> <span style=color:#bd93f9>2</span>
</span></span><span style=display:flex><span>ssd[i, j] <span style=color:#ff79c6>=</span> dist<span style=color:#ff79c6>.</span>sum() <span style=color:#ff79c6>/</span> total_weight  <span style=color:#6272a4># `total_weight` is just for normalization</span>
</span></span></code></pre></div><p>Now this piece of code, doesn&rsquo;t seem all that scary and probably you&rsquo;d do this every now and then in C/C++. However, Python loops are pretty darn slow. My complete code with this ran in about 19.37 seconds. The majority of the time being spent here.</p><p>However, there is a better way to write this. For starters, lets get rid of the <em>huge slicing syntax</em> with&mldr; <code>np.ogrid</code>, of course.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#6272a4># np.ogrid for better indexing</span>
</span></span><span style=display:flex><span>t_row, t_col <span style=color:#ff79c6>=</span> np<span style=color:#ff79c6>.</span>ogrid[<span style=color:#ff79c6>-</span>(window <span style=color:#ff79c6>/</span> <span style=color:#bd93f9>2</span>):(window <span style=color:#ff79c6>/</span> <span style=color:#bd93f9>2</span>) <span style=color:#ff79c6>+</span> <span style=color:#bd93f9>1</span>, <span style=color:#ff79c6>-</span>(window <span style=color:#ff79c6>/</span> <span style=color:#bd93f9>2</span>):(window <span style=color:#ff79c6>/</span> <span style=color:#bd93f9>2</span>) <span style=color:#ff79c6>+</span> <span style=color:#bd93f9>1</span>]
</span></span></code></pre></div><p>You would argue about how would using this be any different, well it&rsquo;s not! It&rsquo;s just cleaner and more convenient to write this once and henceforth simply use the following to extract a template of size <code>window X window</code> about a pixel.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>input_image[i <span style=color:#ff79c6>+</span> t_row, j <span style=color:#ff79c6>+</span> t_col]
</span></span></code></pre></div><p>Much like shifting of origin in Geometry!
Let&rsquo;s rethink, why are we really using the nested loops here? To extract template of the given size pixel by pixel and perform the operations. Is it possible to create such templates beforehand and perform the arithmetic operations directly on all the templates, leveraging the vector property of operators? However, creating separate templates for every pixel would most certainly be expensive on the memory. How can we do this without any additional memory overhead? <code>as_strided</code>!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#6272a4># as_strided to provide a `window` sized window to the `input_image`</span>
</span></span><span style=display:flex><span>y <span style=color:#ff79c6>=</span> as_strided(input_image,
</span></span><span style=display:flex><span>               shape<span style=color:#ff79c6>=</span>(input_image<span style=color:#ff79c6>.</span>shape[<span style=color:#bd93f9>0</span>] <span style=color:#ff79c6>-</span> window_size[<span style=color:#bd93f9>0</span>] <span style=color:#ff79c6>+</span> <span style=color:#bd93f9>1</span>,
</span></span><span style=display:flex><span>                      input_image<span style=color:#ff79c6>.</span>shape[<span style=color:#bd93f9>1</span>] <span style=color:#ff79c6>-</span> window_size[<span style=color:#bd93f9>1</span>] <span style=color:#ff79c6>+</span> <span style=color:#bd93f9>1</span>,) <span style=color:#ff79c6>+</span>
</span></span><span style=display:flex><span>               window_size,
</span></span><span style=display:flex><span>               strides<span style=color:#ff79c6>=</span>input_image<span style=color:#ff79c6>.</span>strides <span style=color:#ff79c6>*</span> <span style=color:#bd93f9>2</span>)
</span></span></code></pre></div><p>Suppose here, that input_image has the dimensions <code>(M, N)</code>, the resulting strided view, y would be a 4D array with <code>(M, N, window, window)</code> dimensions, as specified by the shape key argument. Note that <code>input_image.strides * 2</code> represents a multiplication on a tuple which replicates and concatenates the tuple.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#6272a4># as_strided work here</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>&gt;&gt;&gt;</span> input_image <span style=color:#ff79c6>=</span> np<span style=color:#ff79c6>.</span>arange(<span style=color:#bd93f9>16</span>)<span style=color:#ff79c6>.</span>reshape(<span style=color:#bd93f9>4</span>,<span style=color:#bd93f9>4</span>)
</span></span><span style=display:flex><span><span style=color:#ff79c6>&gt;&gt;&gt;</span> input_image
</span></span><span style=display:flex><span>array([[ <span style=color:#bd93f9>0</span>,  <span style=color:#bd93f9>1</span>,  <span style=color:#bd93f9>2</span>,  <span style=color:#bd93f9>3</span>],
</span></span><span style=display:flex><span>       [ <span style=color:#bd93f9>4</span>,  <span style=color:#bd93f9>5</span>,  <span style=color:#bd93f9>6</span>,  <span style=color:#bd93f9>7</span>],
</span></span><span style=display:flex><span>       [ <span style=color:#bd93f9>8</span>,  <span style=color:#bd93f9>9</span>, <span style=color:#bd93f9>10</span>, <span style=color:#bd93f9>11</span>],
</span></span><span style=display:flex><span>       [<span style=color:#bd93f9>12</span>, <span style=color:#bd93f9>13</span>, <span style=color:#bd93f9>14</span>, <span style=color:#bd93f9>15</span>]])
</span></span><span style=display:flex><span><span style=color:#ff79c6>&gt;&gt;&gt;</span> y <span style=color:#ff79c6>=</span> as_strided(input_image,
</span></span><span style=display:flex><span><span style=color:#ff79c6>...</span>                shape<span style=color:#ff79c6>=</span>(input_image<span style=color:#ff79c6>.</span>shape[<span style=color:#bd93f9>0</span>] <span style=color:#ff79c6>-</span> window_size[<span style=color:#bd93f9>0</span>] <span style=color:#ff79c6>+</span> <span style=color:#bd93f9>1</span>,
</span></span><span style=display:flex><span><span style=color:#ff79c6>...</span>                       input_image<span style=color:#ff79c6>.</span>shape[<span style=color:#bd93f9>1</span>] <span style=color:#ff79c6>-</span> window_size[<span style=color:#bd93f9>1</span>] <span style=color:#ff79c6>+</span> <span style=color:#bd93f9>1</span>,) <span style=color:#ff79c6>+</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>...</span>                window_size,
</span></span><span style=display:flex><span><span style=color:#ff79c6>...</span>                strides<span style=color:#ff79c6>=</span>input_image<span style=color:#ff79c6>.</span>strides <span style=color:#ff79c6>*</span> <span style=color:#bd93f9>2</span>)
</span></span><span style=display:flex><span><span style=color:#ff79c6>&gt;&gt;&gt;</span> y
</span></span><span style=display:flex><span>array([[[[ <span style=color:#bd93f9>0</span>,  <span style=color:#bd93f9>1</span>,  <span style=color:#bd93f9>2</span>],
</span></span><span style=display:flex><span>         [ <span style=color:#bd93f9>4</span>,  <span style=color:#bd93f9>5</span>,  <span style=color:#bd93f9>6</span>],
</span></span><span style=display:flex><span>         [ <span style=color:#bd93f9>8</span>,  <span style=color:#bd93f9>9</span>, <span style=color:#bd93f9>10</span>]],
</span></span><span style=display:flex><span>        [[ <span style=color:#bd93f9>1</span>,  <span style=color:#bd93f9>2</span>,  <span style=color:#bd93f9>3</span>],
</span></span><span style=display:flex><span>         [ <span style=color:#bd93f9>5</span>,  <span style=color:#bd93f9>6</span>,  <span style=color:#bd93f9>7</span>],
</span></span><span style=display:flex><span>         [ <span style=color:#bd93f9>9</span>, <span style=color:#bd93f9>10</span>, <span style=color:#bd93f9>11</span>]]],
</span></span><span style=display:flex><span>       [[[ <span style=color:#bd93f9>4</span>,  <span style=color:#bd93f9>5</span>,  <span style=color:#bd93f9>6</span>],
</span></span><span style=display:flex><span>         [ <span style=color:#bd93f9>8</span>,  <span style=color:#bd93f9>9</span>, <span style=color:#bd93f9>10</span>],
</span></span><span style=display:flex><span>         [<span style=color:#bd93f9>12</span>, <span style=color:#bd93f9>13</span>, <span style=color:#bd93f9>14</span>]],
</span></span><span style=display:flex><span>        [[ <span style=color:#bd93f9>5</span>,  <span style=color:#bd93f9>6</span>,  <span style=color:#bd93f9>7</span>],
</span></span><span style=display:flex><span>         [ <span style=color:#bd93f9>9</span>, <span style=color:#bd93f9>10</span>, <span style=color:#bd93f9>11</span>],
</span></span><span style=display:flex><span>         [<span style=color:#bd93f9>13</span>, <span style=color:#bd93f9>14</span>, <span style=color:#bd93f9>15</span>]]]])
</span></span><span style=display:flex><span><span style=color:#ff79c6>&gt;&gt;&gt;</span> y[<span style=color:#bd93f9>0</span>,<span style=color:#bd93f9>0</span>]
</span></span><span style=display:flex><span>array([[ <span style=color:#bd93f9>0</span>,  <span style=color:#bd93f9>1</span>,  <span style=color:#bd93f9>2</span>],
</span></span><span style=display:flex><span>       [ <span style=color:#bd93f9>4</span>,  <span style=color:#bd93f9>5</span>,  <span style=color:#bd93f9>6</span>],
</span></span><span style=display:flex><span>       [ <span style=color:#bd93f9>8</span>,  <span style=color:#bd93f9>9</span>, <span style=color:#bd93f9>10</span>]])
</span></span><span style=display:flex><span><span style=color:#ff79c6>&gt;&gt;&gt;</span> y[<span style=color:#bd93f9>1</span>,<span style=color:#bd93f9>1</span>]
</span></span><span style=display:flex><span>array([[ <span style=color:#bd93f9>5</span>,  <span style=color:#bd93f9>6</span>,  <span style=color:#bd93f9>7</span>],
</span></span><span style=display:flex><span>       [ <span style=color:#bd93f9>9</span>, <span style=color:#bd93f9>10</span>, <span style=color:#bd93f9>11</span>],
</span></span><span style=display:flex><span>       [<span style=color:#bd93f9>13</span>, <span style=color:#bd93f9>14</span>, <span style=color:#bd93f9>15</span>]])
</span></span><span style=display:flex><span><span style=color:#ff79c6>&gt;&gt;&gt;</span> y<span style=color:#ff79c6>.</span>shape
</span></span><span style=display:flex><span>(<span style=color:#bd93f9>2</span>, <span style=color:#bd93f9>2</span>, <span style=color:#bd93f9>3</span>, <span style=color:#bd93f9>3</span>)
</span></span><span style=display:flex><span><span style=color:#ff79c6>&gt;&gt;&gt;</span> y<span style=color:#ff79c6>.</span>strides
</span></span><span style=display:flex><span>(<span style=color:#bd93f9>32</span>, <span style=color:#bd93f9>8</span>, <span style=color:#bd93f9>32</span>, <span style=color:#bd93f9>8</span>)  <span style=color:#6272a4># 8 is the min step since this data type is &#39;int64&#39; which occupies 8 bytes</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>&gt;&gt;&gt;</span> y<span style=color:#ff79c6>.</span>itemsize
</span></span><span style=display:flex><span><span style=color:#bd93f9>8</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>&gt;&gt;&gt;</span> y<span style=color:#ff79c6>.</span>dtype
</span></span><span style=display:flex><span>dtype(<span style=color:#f1fa8c>&#39;int64&#39;</span>)
</span></span></code></pre></div><p>So, as we can see here, if we iterate through the 1st 2 dimensions of <code>y</code> we will have a <code>3X3</code> array with elements surrounding the inner elements of input_image. I find this to be extremely fascinating and really just brilliant!</p><blockquote><p>Remember: as_strided is just a view, so Without adding any additional memory overhead we are able to accomplish this.</p></blockquote><blockquote><p>Warning: In spite of being just a view, directly performing arithmetic operations on this would allocate additional memory, a 4D that too! This would neutralise the unique advantage this stands to offer. Here, is where things get even more exciting: np.einsum.</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#6272a4># Using `np.einsum` to calculate the SSD without additional mem allocation</span>
</span></span><span style=display:flex><span>ssd <span style=color:#ff79c6>=</span> np<span style=color:#ff79c6>.</span>einsum(<span style=color:#f1fa8c>&#39;ijkl, kl, kl-&gt;ij&#39;</span>, y, template, valid_mask,
</span></span><span style=display:flex><span>                dtype<span style=color:#ff79c6>=</span>np<span style=color:#ff79c6>.</span>float)
</span></span><span style=display:flex><span>ssd <span style=color:#ff79c6>*=</span> <span style=color:#ff79c6>-</span> <span style=color:#bd93f9>2</span>
</span></span><span style=display:flex><span>ssd <span style=color:#ff79c6>+=</span> np<span style=color:#ff79c6>.</span>einsum(<span style=color:#f1fa8c>&#39;ijkl, ijkl, kl-&gt;ij&#39;</span>, y, y, valid_mask)
</span></span><span style=display:flex><span>ssd <span style=color:#ff79c6>+=</span> np<span style=color:#ff79c6>.</span>einsum(<span style=color:#f1fa8c>&#39;ij, ij, ij&#39;</span>, template, template, valid_mask)
</span></span></code></pre></div><p>Instead of directly computing the square of the difference (proving to be rather costly), use the basic algebraic expansion: <code>(a - b)**2 = a**2 - 2*a*b + b**2</code>. Here, observe that, in the first computation, which calculates <code>sample * template</code> the output is being stored in a 2D array. Following which, the subsequent results are simply accumulated in this very array. So in the end, still the overall memory load is just of allocating this 2D array for storing the output, which is what we sought for.</p><p>The complete function which serves as a replacement for the nested loop is as follows:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#6272a4># Complete Template Matching function - no loops</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>def</span> <span style=color:#50fa7b>_sum_sq_diff</span>(input_image, template, valid_mask):
</span></span><span style=display:flex><span>    <span style=color:#f1fa8c>&#34;&#34;&#34;This function performs template matching. The metric used is Sum of
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>    Squared Difference (SSD). The input taken is the template who&#39;s match is
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>    to be found in image.
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>    Parameters
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>    ---------
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>    input_image : array, np.float
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>        Input image of shape (M, N)
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>    template : array, np.float
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>        (window, window) Template who&#39;s match is to be found in input_image.
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>    valid_mask : array, np.float
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>        (window, window), governs differences which are to be considered for
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>        SSD computation. Masks out the unknown or unfilled pixels and gives a
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>        higher weightage to the center pixel, decreasing as the distance from
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>        center pixel increases.
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>    Returns
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>    ------
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>    ssd : array, np.float
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>        (M - window +1, N - window + 1) The desired SSD values for all
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>        positions in the input_image
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    total_weight <span style=color:#ff79c6>=</span> valid_mask<span style=color:#ff79c6>.</span>sum()
</span></span><span style=display:flex><span>    window_size <span style=color:#ff79c6>=</span> template<span style=color:#ff79c6>.</span>shape
</span></span><span style=display:flex><span>    y <span style=color:#ff79c6>=</span> as_strided(input_image,
</span></span><span style=display:flex><span>                   shape<span style=color:#ff79c6>=</span>(input_image<span style=color:#ff79c6>.</span>shape[<span style=color:#bd93f9>0</span>] <span style=color:#ff79c6>-</span> window_size[<span style=color:#bd93f9>0</span>] <span style=color:#ff79c6>+</span> <span style=color:#bd93f9>1</span>,
</span></span><span style=display:flex><span>                          input_image<span style=color:#ff79c6>.</span>shape[<span style=color:#bd93f9>1</span>] <span style=color:#ff79c6>-</span> window_size[<span style=color:#bd93f9>1</span>] <span style=color:#ff79c6>+</span> <span style=color:#bd93f9>1</span>,) <span style=color:#ff79c6>+</span>
</span></span><span style=display:flex><span>                    window_size,
</span></span><span style=display:flex><span>                    strides<span style=color:#ff79c6>=</span>input_image<span style=color:#ff79c6>.</span>strides <span style=color:#ff79c6>*</span> <span style=color:#bd93f9>2</span>)
</span></span><span style=display:flex><span>    ssd <span style=color:#ff79c6>=</span> np<span style=color:#ff79c6>.</span>einsum(<span style=color:#f1fa8c>&#39;ijkl, kl, kl-&gt;ij&#39;</span>, y, template, valid_mask,
</span></span><span style=display:flex><span>                    dtype<span style=color:#ff79c6>=</span>np<span style=color:#ff79c6>.</span>float)
</span></span><span style=display:flex><span>    <span style=color:#6272a4># Refer to the comment below for the explanation</span>
</span></span><span style=display:flex><span>    ssd <span style=color:#ff79c6>*=</span> <span style=color:#ff79c6>-</span> <span style=color:#bd93f9>2</span>
</span></span><span style=display:flex><span>    ssd <span style=color:#ff79c6>+=</span> np<span style=color:#ff79c6>.</span>einsum(<span style=color:#f1fa8c>&#39;ijkl, ijkl, kl-&gt;ij&#39;</span>, y, y, valid_mask)
</span></span><span style=display:flex><span>    ssd <span style=color:#ff79c6>+=</span> np<span style=color:#ff79c6>.</span>einsum(<span style=color:#f1fa8c>&#39;ij, ij, ij&#39;</span>, template, template, valid_mask)
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> ssd <span style=color:#ff79c6>/</span> total_weight
</span></span></code></pre></div><p><strong>Comments</strong></p><p>Above, since &lsquo;kl&rsquo; are repeated on LHS, we first compute the product of elements in the 3rd and 4th dim of <code>y</code> with corresponding elements of <code>template</code> and <code>valid_mask</code> and sum. Since, the output labels are &lsquo;ij&rsquo;, we want the summation along the other axes. Hence, each element of <code>ssd</code> corresponds to element wise product of <code>template</code> and <code>valid_mask</code> with the <code>(3, 3)</code> &ldquo;sample patch&rdquo; stored in the 3rd and 4th dimensions of <code>y</code>.</p><p><strong>Results</strong></p><p>The fascinating part is that testing this implementation for the same test case as the one used for nested loops completes the computation in about 0.342 seconds! So that&rsquo;s 19.37 -> 0.34 seconds!</p><p>I am absolutely blown away by NumPy, and if not for anything else, I am definitely thankful to GSoC and scikit-image for introducing me to NumPy!</p><p>Next post will be on my second module for GSoC: Texture Synthesis, whose initial implementation is complete and now in the review phase.</p><p>Cheers!</p><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><ul><li><p>Much of the content of this post is inspired from the StackOverflow answer to my question by Jaime, of scikit-image community. Thanks a lot! <a href="http://stackoverflow.com/questions/17881489/faster-way-to-calculate-sum-of-squared-difference-between-an-image-m-n-and-a/17885996?noredirect=1#17885996">Answer</a></p></li><li><p><a href=http://scipy-lectures.github.io/>http://scipy-lectures.github.io/</a></p></li><li><p>Van Der Walt, Stefan, S. Chris Colbert, and Gael Varoquaux. “The NumPy array: a structure for efficient numerical computation.” Computing in Science & Engineering 13.2 (2011): 22-30.</p></li></ul><h2 id=related-articles>Related articles<a hidden class=anchor aria-hidden=true href=#related-articles>#</a></h2><ul><li><p><a href=notion://www.notion.so/2013/07/numpy-the-tricks-of-trade-part-i/>NumPy: The tricks of the trade (Part I)</a></p></li><li><p><a href="https://www.youtube.com/watch?v=G-Iep_MnSv8">Diving into NumPy Code, SciPy 2013 Tutorial</a></p></li><li><p><a href="https://www.youtube.com/watch?v=vWkb7VahaXQ">Using NumPy to Perform Mathematical Operations in Python</a></p></li></ul><h2 id=updates>Updates<a hidden class=anchor aria-hidden=true href=#updates>#</a></h2><ul><li>[Feb 2, 2013] Added another example to the section on <code>np.einsum</code> and comment explaining the role of <code>np.einsum</code> in the <code>_sum_sq_diff</code> function. Thanks for pointing out, Juan!</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://chintak.github.io/tags/numpy/>numpy</a></li></ul><nav class=paginav><a class=next href=https://chintak.github.io/posts/2013-07-15-numpy-the-tricks-of-trade-part-i/><span class=title>Next »</span><br><span>NumPy: The Tricks of Trade (Part I)</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share NumPy: The tricks of the trade (Part II) on twitter" href="https://twitter.com/intent/tweet/?text=NumPy%3a%20The%20tricks%20of%20the%20trade%20%28Part%20II%29&amp;url=https%3a%2f%2fchintak.github.io%2fposts%2f2013-07-31-numpy-the-tricks-of-the-trade-part-ii%2f&amp;hashtags=numpy"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share NumPy: The tricks of the trade (Part II) on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fchintak.github.io%2fposts%2f2013-07-31-numpy-the-tricks-of-the-trade-part-ii%2f&amp;title=NumPy%3a%20The%20tricks%20of%20the%20trade%20%28Part%20II%29&amp;summary=NumPy%3a%20The%20tricks%20of%20the%20trade%20%28Part%20II%29&amp;source=https%3a%2f%2fchintak.github.io%2fposts%2f2013-07-31-numpy-the-tricks-of-the-trade-part-ii%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share NumPy: The tricks of the trade (Part II) on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fchintak.github.io%2fposts%2f2013-07-31-numpy-the-tricks-of-the-trade-part-ii%2f&title=NumPy%3a%20The%20tricks%20of%20the%20trade%20%28Part%20II%29"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share NumPy: The tricks of the trade (Part II) on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fchintak.github.io%2fposts%2f2013-07-31-numpy-the-tricks-of-the-trade-part-ii%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share NumPy: The tricks of the trade (Part II) on whatsapp" href="https://api.whatsapp.com/send?text=NumPy%3a%20The%20tricks%20of%20the%20trade%20%28Part%20II%29%20-%20https%3a%2f%2fchintak.github.io%2fposts%2f2013-07-31-numpy-the-tricks-of-the-trade-part-ii%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share NumPy: The tricks of the trade (Part II) on telegram" href="https://telegram.me/share/url?text=NumPy%3a%20The%20tricks%20of%20the%20trade%20%28Part%20II%29&amp;url=https%3a%2f%2fchintak.github.io%2fposts%2f2013-07-31-numpy-the-tricks-of-the-trade-part-ii%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share NumPy: The tricks of the trade (Part II) on ycombinator" href="https://news.ycombinator.com/submitlink?t=NumPy%3a%20The%20tricks%20of%20the%20trade%20%28Part%20II%29&u=https%3a%2f%2fchintak.github.io%2fposts%2f2013-07-31-numpy-the-tricks-of-the-trade-part-ii%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://chintak.github.io/>Notable ML Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>